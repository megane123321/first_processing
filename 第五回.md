# 初めてのprocessing 第五回 クラスを定義する
processingでは自身のオリジナルのクラスを定義することができる。  
ここで簡単なオブジェクト指向プログラミングに触れてみよう。

## なぜクラスを定義するのか
[第四章](第四章.md)で解説した通り、processingでは標準で様々なクラスを利用することができる。 
そのため、自分で新たにクラスを実装せずとも変数と関数をたくさん作成すれば解決できそうな気がする。

では、なぜクラスを定義したほうが良いのか。
それは、簡単に同じ構造を持つデータを作ることができるからだ。

## クラスの定義
クラスは`class クラス名`で宣言し、変数のような形でフィールドを、関数の形でメソッドを定義する。

```java
class クラス名{
  フィールドやメソッド等
}
```
図1. クラスの基本構造

下は簡単に実装されたクラスの例である。

<div id="図2"></div>

```java
class Point{
  float x=0,y=0;//フィールド

  float distance(Point p){//メソッド
    return sqrt(pow(x-p.x,2)+pow(y-p.y,2));//各座標の差の二乗の和の平方根 つまり距離
  }
  
  void setPoint(float x,float y){//メソッド
    this.x=x;//thisが自身のインスタンスを意味するため、this.xはフィールドのxを意味し、xはメソッドの引数のxを意味する。
    this.y=y;
  }
}
```
図2. xy平面上で他の点との距離を調べられるPointクラス

<div id="図3"></div>

```java
void setup(){
  Point p1=new Point(),p2=new Point();
  p1.setPoint(0,0);
  p2.setPoint(3,4);
  println(p1.distance(p2));
}
```
図3. 上のクラスを用いたプログラム例

## コンストラクタ
コンストラクタはインスタンスが生成されたときに実行される特別なメソッドである。返り値はないため返り値の型は指定しない。  
コンストラクタを用いて[図2](#図2)のPointクラスのxとyの初期化を行う例を以下に示す。

```java
class Point{
  float x,y;
  
  Point(){//コンストラクタ名はクラス名と同じ
    setPoint(0,0);
  }

  float distance(Point p){
    return sqrt(pow(x-p.x,2)+pow(y-p.y,2));
  }
  
  void setPoint(float x,float y){
    this.x=x;
    this.y=y;
  }
}
```
図4. コンストラクタ内で座標の初期化

また、コンストラクタにも引数を与えることができ、引数はインスタンス化を行うときに与える。

<div id="図5"></div>

```java
class Point{
  float x,y;
  
  Point(){
    this(0,0);//コンストラクタの一行目でのみthis()で他のコンストラクタを呼び出せる
  }
  
  Point(float x,float y){
    setPoint(x,y);
  }

  float distance(Point p){
    return sqrt(pow(x-p.x,2)+pow(y-p.y,2));
  }
  
  void setPoint(float x,float y){
    this.x=x;
    this.y=y;
  }
}
```
図5. 引数を持つコンストラクタを実装されたPointクラス

```java
void setup(){
  Point p1=new Point(0,0),p2=new Point(3,4);//ここでコンストラクタに引数を与える
  println(p1.distance(p2));
}
```
図6. [図3](#図3)と等価

## おまけ(静的フィールド)
フィールドにはすべてのインスタンスで値が共有されるフィールドが存在する。
だいたいの場合、final修飾子と合わせて定数のような使い方をされる。

```java
static final int TEST_VALUE=5;
```
図7. 静的フィールドの記述例

## おまけ(クラスの継承)
processingにはほかのクラスの機能を受け継いだクラスを作ることができる機能がある。  
フィールドやメソッドを受け継ぐことができるため似た機能を持つクラスを作る際に便利である。  
また、共通の金型を作り継承したクラスで細かな処理を行うなどの使われ方もする。

継承元にされたクラスを親クラス、親クラスを継承をしたクラスを子クラスという。  
また、子クラスのインスタンスは親クラスの変数に代入することができる。

```java
class DrawablePoint extends Point{
  DrawablePoint(){
    super();//super()で親クラスのコンストラクタの呼び出し
    setSize(DEFAULT_SIZE);
  }
  
  DrawablePoint(float x,float y){
    this(x,y,DEFAULT_SIZE);
  }
  
  DrawablePoint(float x,float y,float size){
    super(x,y);
    setSize(size);
  }
  
  static final float DEFAULT_SIZE=10;
  float size;
  
  void setSize(float size){
    this.size=size;
  }
  
  void draw(){//描画メソッド
    circle(x,y,size);
  }
}
```
図8. [図5](#図5)のPointクラスを継承したDrawablePointクラス

また、子クラスは親クラスのメソッドを上書きすることができる。これをオーバーライドと呼ぶ。

```java
class Test{
  void printTest(){
    println("親クラス");
  }
}

class Test2 extends Test{
  @Override//書かなくてもよいが書いてあるとデバッグの時わかりやすい
  void printTest(){//オーバーライド
    println("子クラス");
  }
  
  void otherPrint(){
    super.printTest();//superで親クラスを参照
  }
}
```
図9. オーバーライドの例

## 演習問題
問1. 
